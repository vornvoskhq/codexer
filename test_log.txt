Installing/updating dependencies from requirements.txt...
Running pytest...
============================= test session starts ==============================
platform linux -- Python 3.12.3, pytest-8.4.1, pluggy-1.6.0
rootdir: /mnt/c/Users/Vorn/Projects/codexer
collected 33 items

tests/test_advanced_agent_tools.py ..                                    [  6%]
tests/test_agent.py ....FF                                               [ 24%]
tests/test_code_analysis.py ..                                           [ 30%]
tests/test_file_system.py ........                                       [ 54%]
tests/test_file_tools.py ...                                             [ 63%]
tests/test_git_operations.py F                                           [ 66%]
tests/test_git_tools.py F                                                [ 69%]
tests/test_ide_tools.py ...                                              [ 78%]
tests/test_llm_agent.py FFF                                              [ 87%]
tests/test_project_tools.py ..                                           [ 93%]
tests/test_specialized_tools.py ..                                       [100%]

=================================== FAILURES ===================================
_____________________________ test_run_git_status ______________________________

name = 'integration.framework.functions_git'

    def resolve(name: str) -> object:
        # Simplified from zope.dottedname.
        parts = name.split(".")
    
        used = parts.pop(0)
        found: object = __import__(used)
        for part in parts:
            used += "." + part
            try:
                found = getattr(found, part)
            except AttributeError:
                pass
            else:
                continue
            # We use explicit un-nesting of the handling block in order
            # to avoid nested exceptions.
            try:
>               __import__(used)
E               ModuleNotFoundError: No module named 'integration.framework.functions_git'

.venv/lib/python3.12/site-packages/_pytest/monkeypatch.py:77: ModuleNotFoundError

The above exception was the direct cause of the following exception:

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x785ac1e5a9f0>

    def test_run_git_status(monkeypatch):
        agent = AgenticExecutor()
        path = "/repo"
        def fake_git_status(p):
            assert p == path
            return "On branch main\nnothing to commit"
>       monkeypatch.setattr("integration.framework.functions_git.git_status", fake_git_status)

tests/test_agent.py:79: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/_pytest/monkeypatch.py:102: in derive_importpath
    target = resolve(module)
             ^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'integration.framework.functions_git'

    def resolve(name: str) -> object:
        # Simplified from zope.dottedname.
        parts = name.split(".")
    
        used = parts.pop(0)
        found: object = __import__(used)
        for part in parts:
            used += "." + part
            try:
                found = getattr(found, part)
            except AttributeError:
                pass
            else:
                continue
            # We use explicit un-nesting of the handling block in order
            # to avoid nested exceptions.
            try:
                __import__(used)
            except ImportError as ex:
                expected = str(ex).split()[-1]
                if expected == used:
                    raise
                else:
>                   raise ImportError(f"import error in {used}: {ex}") from ex
E                   ImportError: import error in integration.framework.functions_git: No module named 'integration.framework.functions_git'

.venv/lib/python3.12/site-packages/_pytest/monkeypatch.py:83: ImportError
_____________________________ test_run_git_commit ______________________________

name = 'integration.framework.functions_git'

    def resolve(name: str) -> object:
        # Simplified from zope.dottedname.
        parts = name.split(".")
    
        used = parts.pop(0)
        found: object = __import__(used)
        for part in parts:
            used += "." + part
            try:
                found = getattr(found, part)
            except AttributeError:
                pass
            else:
                continue
            # We use explicit un-nesting of the handling block in order
            # to avoid nested exceptions.
            try:
>               __import__(used)
E               ModuleNotFoundError: No module named 'integration.framework.functions_git'

.venv/lib/python3.12/site-packages/_pytest/monkeypatch.py:77: ModuleNotFoundError

The above exception was the direct cause of the following exception:

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x785ac1e58440>

    def test_run_git_commit(monkeypatch):
        agent = AgenticExecutor()
        path = "/repo"
        files = ["a.txt", "b.txt"]
        def fake_git_commit(p, fs):
            assert p == path and fs == files
            return "Committed 2 files"
>       monkeypatch.setattr("integration.framework.functions_git.git_commit", fake_git_commit)

tests/test_agent.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/_pytest/monkeypatch.py:102: in derive_importpath
    target = resolve(module)
             ^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'integration.framework.functions_git'

    def resolve(name: str) -> object:
        # Simplified from zope.dottedname.
        parts = name.split(".")
    
        used = parts.pop(0)
        found: object = __import__(used)
        for part in parts:
            used += "." + part
            try:
                found = getattr(found, part)
            except AttributeError:
                pass
            else:
                continue
            # We use explicit un-nesting of the handling block in order
            # to avoid nested exceptions.
            try:
                __import__(used)
            except ImportError as ex:
                expected = str(ex).split()[-1]
                if expected == used:
                    raise
                else:
>                   raise ImportError(f"import error in {used}: {ex}") from ex
E                   ImportError: import error in integration.framework.functions_git: No module named 'integration.framework.functions_git'

.venv/lib/python3.12/site-packages/_pytest/monkeypatch.py:83: ImportError
__________________________ test_git_status_and_commit __________________________

tmp_path = PosixPath('/tmp/pytest-of-vorn/pytest-2/test_git_status_and_commit0')

    def test_git_status_and_commit(tmp_path):
        # Setup: create a new git repo
        repo_dir = tmp_path / "repo"
        repo_dir.mkdir()
        os.chdir(repo_dir)
        os.system("git init")
    
        # Create a file and check status
        file1 = repo_dir / "file1.txt"
        write_file(file1, "hello world")
>       s1 = status(str(repo_dir))
             ^^^^^^^^^^^^^^^^^^^^^

/mnt/c/Users/Vorn/Projects/codexer/tests/test_git_operations.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/mnt/c/Users/Vorn/Projects/codexer/integration/functions/git_operations.py:32: in status
    staged = [item.a_path for item in repo.index.diff("HEAD") if item.change_type != "D"]
                                      ^^^^^^^^^^^^^^^^^^^^^^^
/mnt/c/Users/Vorn/Projects/codexer/.venv/lib/python3.12/site-packages/git/index/base.py:1517: in diff
    other = self.repo.rev_parse(other)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^
/mnt/c/Users/Vorn/Projects/codexer/.venv/lib/python3.12/site-packages/git/repo/fun.py:415: in rev_parse
    obj = name_to_object(repo, rev)
          ^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

repo = <git.repo.base.Repo '/tmp/pytest-of-vorn/pytest-2/test_git_status_and_commit0/repo/.git'>
name = 'HEAD', return_ref = False

    def name_to_object(repo: "Repo", name: str, return_ref: bool = False) -> Union[AnyGitObject, SymbolicReference]:
        """
        :return:
            Object specified by the given name - hexshas (short and long) as well as
            references are supported.
    
        :param return_ref:
            If ``True``, and name specifies a reference, we will return the reference
            instead of the object. Otherwise it will raise :exc:`~gitdb.exc.BadObject` or
            :exc:`~gitdb.exc.BadName`.
        """
        hexsha: Union[None, str, bytes] = None
    
        # Is it a hexsha? Try the most common ones, which is 7 to 40.
        if repo.re_hexsha_shortened.match(name):
            if len(name) != 40:
                # Find long sha for short sha.
                hexsha = short_to_long(repo.odb, name)
            else:
                hexsha = name
            # END handle short shas
        # END find sha if it matches
    
        # If we couldn't find an object for what seemed to be a short hexsha, try to find it
        # as reference anyway, it could be named 'aaa' for instance.
        if hexsha is None:
            for base in (
                "%s",
                "refs/%s",
                "refs/tags/%s",
                "refs/heads/%s",
                "refs/remotes/%s",
                "refs/remotes/%s/HEAD",
            ):
                try:
                    hexsha = SymbolicReference.dereference_recursive(repo, base % name)
                    if return_ref:
                        return SymbolicReference(repo, base % name)
                    # END handle symbolic ref
                    break
                except ValueError:
                    pass
            # END for each base
        # END handle hexsha
    
        # Didn't find any ref, this is an error.
        if return_ref:
            raise BadObject("Couldn't find reference named %r" % name)
        # END handle return ref
    
        # Tried everything ? fail.
        if hexsha is None:
>           raise BadName(name)
E           gitdb.exc.BadName: Ref 'HEAD' did not resolve to an object

/mnt/c/Users/Vorn/Projects/codexer/.venv/lib/python3.12/site-packages/git/repo/fun.py:202: BadName
----------------------------- Captured stdout call -----------------------------
Initialized empty Git repository in /tmp/pytest-of-vorn/pytest-2/test_git_status_and_commit0/repo/.git/
----------------------------- Captured stderr call -----------------------------
hint: Using 'master' as the name for the initial branch. This default branch name
hint: is subject to change. To configure the initial branch name to use in all
hint: of your new repositories, which will suppress this warning, call:
hint: 
hint: 	git config --global init.defaultBranch <name>
hint: 
hint: Names commonly chosen instead of 'master' are 'main', 'trunk' and
hint: 'development'. The just-created branch can be renamed via this command:
hint: 
hint: 	git branch -m <name>
__________________________ test_git_status_and_commit __________________________

tmp_path = PosixPath('/tmp/pytest-of-vorn/pytest-2/test_git_status_and_commit1')

    def test_git_status_and_commit(tmp_path):
        repo_dir = tmp_path / "repo"
        repo_dir.mkdir()
        os.chdir(repo_dir)
        os.system("git init")
    
        file1 = repo_dir / "file1.txt"
        write_file(file1, "hello world")
>       s1 = git_tools.status(str(repo_dir))
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/mnt/c/Users/Vorn/Projects/codexer/tests/test_git_tools.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/mnt/c/Users/Vorn/Projects/codexer/integration/tools/git_tools.py:32: in status
    staged = [item.a_path for item in repo.index.diff("HEAD") if item.change_type != "D"]
                                      ^^^^^^^^^^^^^^^^^^^^^^^
/mnt/c/Users/Vorn/Projects/codexer/.venv/lib/python3.12/site-packages/git/index/base.py:1517: in diff
    other = self.repo.rev_parse(other)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^
/mnt/c/Users/Vorn/Projects/codexer/.venv/lib/python3.12/site-packages/git/repo/fun.py:415: in rev_parse
    obj = name_to_object(repo, rev)
          ^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

repo = <git.repo.base.Repo '/tmp/pytest-of-vorn/pytest-2/test_git_status_and_commit1/repo/.git'>
name = 'HEAD', return_ref = False

    def name_to_object(repo: "Repo", name: str, return_ref: bool = False) -> Union[AnyGitObject, SymbolicReference]:
        """
        :return:
            Object specified by the given name - hexshas (short and long) as well as
            references are supported.
    
        :param return_ref:
            If ``True``, and name specifies a reference, we will return the reference
            instead of the object. Otherwise it will raise :exc:`~gitdb.exc.BadObject` or
            :exc:`~gitdb.exc.BadName`.
        """
        hexsha: Union[None, str, bytes] = None
    
        # Is it a hexsha? Try the most common ones, which is 7 to 40.
        if repo.re_hexsha_shortened.match(name):
            if len(name) != 40:
                # Find long sha for short sha.
                hexsha = short_to_long(repo.odb, name)
            else:
                hexsha = name
            # END handle short shas
        # END find sha if it matches
    
        # If we couldn't find an object for what seemed to be a short hexsha, try to find it
        # as reference anyway, it could be named 'aaa' for instance.
        if hexsha is None:
            for base in (
                "%s",
                "refs/%s",
                "refs/tags/%s",
                "refs/heads/%s",
                "refs/remotes/%s",
                "refs/remotes/%s/HEAD",
            ):
                try:
                    hexsha = SymbolicReference.dereference_recursive(repo, base % name)
                    if return_ref:
                        return SymbolicReference(repo, base % name)
                    # END handle symbolic ref
                    break
                except ValueError:
                    pass
            # END for each base
        # END handle hexsha
    
        # Didn't find any ref, this is an error.
        if return_ref:
            raise BadObject("Couldn't find reference named %r" % name)
        # END handle return ref
    
        # Tried everything ? fail.
        if hexsha is None:
>           raise BadName(name)
E           gitdb.exc.BadName: Ref 'HEAD' did not resolve to an object

/mnt/c/Users/Vorn/Projects/codexer/.venv/lib/python3.12/site-packages/git/repo/fun.py:202: BadName
----------------------------- Captured stdout call -----------------------------
Initialized empty Git repository in /tmp/pytest-of-vorn/pytest-2/test_git_status_and_commit1/repo/.git/
----------------------------- Captured stderr call -----------------------------
hint: Using 'master' as the name for the initial branch. This default branch name
hint: is subject to change. To configure the initial branch name to use in all
hint: of your new repositories, which will suppress this warning, call:
hint: 
hint: 	git config --global init.defaultBranch <name>
hint: 
hint: Names commonly chosen instead of 'master' are 'main', 'trunk' and
hint: 'development'. The just-created branch can be renamed via this command:
hint: 
hint: 	git branch -m <name>
___________________________ test_llm_agent_run_tool ____________________________

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x785ac1dd1850>

    def test_llm_agent_run_tool(monkeypatch):
        # Patch OpenRouter call and AgenticExecutor
        os.environ["OPENROUTER_API_KEY"] = "test-key"
>       agent = LLMAgent(api_key="test-key")
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/mnt/c/Users/Vorn/Projects/codexer/tests/test_llm_agent.py:13: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/mnt/c/Users/Vorn/Projects/codexer/integration/framework/llm_agent.py:39: in __init__
    self.tools_doc = self._build_tools_doc()
                     ^^^^^^^^^^^^^^^^^^^^^^^
/mnt/c/Users/Vorn/Projects/codexer/integration/framework/llm_agent.py:62: in _build_tools_doc
    sig = str(inspect.signature(fn))
              ^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/inspect.py:3310: in signature
    return Signature.from_callable(obj, follow_wrapped=follow_wrapped,
/usr/lib/python3.12/inspect.py:3054: in from_callable
    return _signature_from_callable(obj, sigcls=cls,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

obj = <class 'git.exc.InvalidGitRepositoryError'>

    def _signature_from_callable(obj, *,
                                 follow_wrapper_chains=True,
                                 skip_bound_arg=True,
                                 globals=None,
                                 locals=None,
                                 eval_str=False,
                                 sigcls):
    
        """Private helper function to get signature for arbitrary
        callable objects.
        """
    
        _get_signature_of = functools.partial(_signature_from_callable,
                                    follow_wrapper_chains=follow_wrapper_chains,
                                    skip_bound_arg=skip_bound_arg,
                                    globals=globals,
                                    locals=locals,
                                    sigcls=sigcls,
                                    eval_str=eval_str)
    
        if not callable(obj):
            raise TypeError('{!r} is not a callable object'.format(obj))
    
        if isinstance(obj, types.MethodType):
            # In this case we skip the first parameter of the underlying
            # function (usually `self` or `cls`).
            sig = _get_signature_of(obj.__func__)
    
            if skip_bound_arg:
                return _signature_bound_method(sig)
            else:
                return sig
    
        # Was this function wrapped by a decorator?
        if follow_wrapper_chains:
            # Unwrap until we find an explicit signature or a MethodType (which will be
            # handled explicitly below).
            obj = unwrap(obj, stop=(lambda f: hasattr(f, "__signature__")
                                    or isinstance(f, types.MethodType)))
            if isinstance(obj, types.MethodType):
                # If the unwrapped object is a *method*, we might want to
                # skip its first parameter (self).
                # See test_signature_wrapped_bound_method for details.
                return _get_signature_of(obj)
    
        try:
            sig = obj.__signature__
        except AttributeError:
            pass
        else:
            if sig is not None:
                # since __text_signature__ is not writable on classes, __signature__
                # may contain text (or be a callable that returns text);
                # if so, convert it
                o_sig = sig
                if not isinstance(sig, (Signature, str)) and callable(sig):
                    sig = sig()
                if isinstance(sig, str):
                    sig = _signature_fromstr(sigcls, obj, sig)
                if not isinstance(sig, Signature):
                    raise TypeError(
                        'unexpected object {!r} in __signature__ '
                        'attribute'.format(o_sig))
                return sig
    
        try:
            partialmethod = obj._partialmethod
        except AttributeError:
            pass
        else:
            if isinstance(partialmethod, functools.partialmethod):
                # Unbound partialmethod (see functools.partialmethod)
                # This means, that we need to calculate the signature
                # as if it's a regular partial object, but taking into
                # account that the first positional argument
                # (usually `self`, or `cls`) will not be passed
                # automatically (as for boundmethods)
    
                wrapped_sig = _get_signature_of(partialmethod.func)
    
                sig = _signature_get_partial(wrapped_sig, partialmethod, (None,))
                first_wrapped_param = tuple(wrapped_sig.parameters.values())[0]
                if first_wrapped_param.kind is Parameter.VAR_POSITIONAL:
                    # First argument of the wrapped callable is `*args`, as in
                    # `partialmethod(lambda *args)`.
                    return sig
                else:
                    sig_params = tuple(sig.parameters.values())
                    assert (not sig_params or
                            first_wrapped_param is not sig_params[0])
                    new_params = (first_wrapped_param,) + sig_params
                    return sig.replace(parameters=new_params)
    
        if isfunction(obj) or _signature_is_functionlike(obj):
            # If it's a pure Python function, or an object that is duck type
            # of a Python function (Cython functions, for instance), then:
            return _signature_from_function(sigcls, obj,
                                            skip_bound_arg=skip_bound_arg,
                                            globals=globals, locals=locals, eval_str=eval_str)
    
        if _signature_is_builtin(obj):
            return _signature_from_builtin(sigcls, obj,
                                           skip_bound_arg=skip_bound_arg)
    
        if isinstance(obj, functools.partial):
            wrapped_sig = _get_signature_of(obj.func)
            return _signature_get_partial(wrapped_sig, obj)
    
        if isinstance(obj, type):
            # obj is a class or a metaclass
    
            # First, let's see if it has an overloaded __call__ defined
            # in its metaclass
            call = _signature_get_user_defined_method(type(obj), '__call__')
            if call is not None:
                return _get_signature_of(call)
    
            new = _signature_get_user_defined_method(obj, '__new__')
            init = _signature_get_user_defined_method(obj, '__init__')
    
            # Go through the MRO and see if any class has user-defined
            # pure Python __new__ or __init__ method
            for base in obj.__mro__:
                # Now we check if the 'obj' class has an own '__new__' method
                if new is not None and '__new__' in base.__dict__:
                    sig = _get_signature_of(new)
                    if skip_bound_arg:
                        sig = _signature_bound_method(sig)
                    return sig
                # or an own '__init__' method
                elif init is not None and '__init__' in base.__dict__:
                    return _get_signature_of(init)
    
            # At this point we know, that `obj` is a class, with no user-
            # defined '__init__', '__new__', or class-level '__call__'
    
            for base in obj.__mro__[:-1]:
                # Since '__text_signature__' is implemented as a
                # descriptor that extracts text signature from the
                # class docstring, if 'obj' is derived from a builtin
                # class, its own '__text_signature__' may be 'None'.
                # Therefore, we go through the MRO (except the last
                # class in there, which is 'object') to find the first
                # class with non-empty text signature.
                try:
                    text_sig = base.__text_signature__
                except AttributeError:
                    pass
                else:
                    if text_sig:
                        # If 'base' class has a __text_signature__ attribute:
                        # return a signature based on it
                        return _signature_fromstr(sigcls, base, text_sig)
    
            # No '__text_signature__' was found for the 'obj' class.
            # Last option is to check if its '__init__' is
            # object.__init__ or type.__init__.
            if type not in obj.__mro__:
                # We have a class (not metaclass), but no user-defined
                # __init__ or __new__ for it
                if (obj.__init__ is object.__init__ and
                    obj.__new__ is object.__new__):
                    # Return a signature of 'object' builtin.
                    return sigcls.from_callable(object)
                else:
>                   raise ValueError(
                        'no signature found for builtin type {!r}'.format(obj))
E                   ValueError: no signature found for builtin type <class 'git.exc.InvalidGitRepositoryError'>

/usr/lib/python3.12/inspect.py:2635: ValueError
__________________________ test_llm_agent_final_only ___________________________

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x785ac0f89f10>

    def test_llm_agent_final_only(monkeypatch):
        os.environ["OPENROUTER_API_KEY"] = "test-key"
>       agent = LLMAgent(api_key="test-key")
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/mnt/c/Users/Vorn/Projects/codexer/tests/test_llm_agent.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/mnt/c/Users/Vorn/Projects/codexer/integration/framework/llm_agent.py:39: in __init__
    self.tools_doc = self._build_tools_doc()
                     ^^^^^^^^^^^^^^^^^^^^^^^
/mnt/c/Users/Vorn/Projects/codexer/integration/framework/llm_agent.py:62: in _build_tools_doc
    sig = str(inspect.signature(fn))
              ^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/inspect.py:3310: in signature
    return Signature.from_callable(obj, follow_wrapped=follow_wrapped,
/usr/lib/python3.12/inspect.py:3054: in from_callable
    return _signature_from_callable(obj, sigcls=cls,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

obj = <class 'git.exc.InvalidGitRepositoryError'>

    def _signature_from_callable(obj, *,
                                 follow_wrapper_chains=True,
                                 skip_bound_arg=True,
                                 globals=None,
                                 locals=None,
                                 eval_str=False,
                                 sigcls):
    
        """Private helper function to get signature for arbitrary
        callable objects.
        """
    
        _get_signature_of = functools.partial(_signature_from_callable,
                                    follow_wrapper_chains=follow_wrapper_chains,
                                    skip_bound_arg=skip_bound_arg,
                                    globals=globals,
                                    locals=locals,
                                    sigcls=sigcls,
                                    eval_str=eval_str)
    
        if not callable(obj):
            raise TypeError('{!r} is not a callable object'.format(obj))
    
        if isinstance(obj, types.MethodType):
            # In this case we skip the first parameter of the underlying
            # function (usually `self` or `cls`).
            sig = _get_signature_of(obj.__func__)
    
            if skip_bound_arg:
                return _signature_bound_method(sig)
            else:
                return sig
    
        # Was this function wrapped by a decorator?
        if follow_wrapper_chains:
            # Unwrap until we find an explicit signature or a MethodType (which will be
            # handled explicitly below).
            obj = unwrap(obj, stop=(lambda f: hasattr(f, "__signature__")
                                    or isinstance(f, types.MethodType)))
            if isinstance(obj, types.MethodType):
                # If the unwrapped object is a *method*, we might want to
                # skip its first parameter (self).
                # See test_signature_wrapped_bound_method for details.
                return _get_signature_of(obj)
    
        try:
            sig = obj.__signature__
        except AttributeError:
            pass
        else:
            if sig is not None:
                # since __text_signature__ is not writable on classes, __signature__
                # may contain text (or be a callable that returns text);
                # if so, convert it
                o_sig = sig
                if not isinstance(sig, (Signature, str)) and callable(sig):
                    sig = sig()
                if isinstance(sig, str):
                    sig = _signature_fromstr(sigcls, obj, sig)
                if not isinstance(sig, Signature):
                    raise TypeError(
                        'unexpected object {!r} in __signature__ '
                        'attribute'.format(o_sig))
                return sig
    
        try:
            partialmethod = obj._partialmethod
        except AttributeError:
            pass
        else:
            if isinstance(partialmethod, functools.partialmethod):
                # Unbound partialmethod (see functools.partialmethod)
                # This means, that we need to calculate the signature
                # as if it's a regular partial object, but taking into
                # account that the first positional argument
                # (usually `self`, or `cls`) will not be passed
                # automatically (as for boundmethods)
    
                wrapped_sig = _get_signature_of(partialmethod.func)
    
                sig = _signature_get_partial(wrapped_sig, partialmethod, (None,))
                first_wrapped_param = tuple(wrapped_sig.parameters.values())[0]
                if first_wrapped_param.kind is Parameter.VAR_POSITIONAL:
                    # First argument of the wrapped callable is `*args`, as in
                    # `partialmethod(lambda *args)`.
                    return sig
                else:
                    sig_params = tuple(sig.parameters.values())
                    assert (not sig_params or
                            first_wrapped_param is not sig_params[0])
                    new_params = (first_wrapped_param,) + sig_params
                    return sig.replace(parameters=new_params)
    
        if isfunction(obj) or _signature_is_functionlike(obj):
            # If it's a pure Python function, or an object that is duck type
            # of a Python function (Cython functions, for instance), then:
            return _signature_from_function(sigcls, obj,
                                            skip_bound_arg=skip_bound_arg,
                                            globals=globals, locals=locals, eval_str=eval_str)
    
        if _signature_is_builtin(obj):
            return _signature_from_builtin(sigcls, obj,
                                           skip_bound_arg=skip_bound_arg)
    
        if isinstance(obj, functools.partial):
            wrapped_sig = _get_signature_of(obj.func)
            return _signature_get_partial(wrapped_sig, obj)
    
        if isinstance(obj, type):
            # obj is a class or a metaclass
    
            # First, let's see if it has an overloaded __call__ defined
            # in its metaclass
            call = _signature_get_user_defined_method(type(obj), '__call__')
            if call is not None:
                return _get_signature_of(call)
    
            new = _signature_get_user_defined_method(obj, '__new__')
            init = _signature_get_user_defined_method(obj, '__init__')
    
            # Go through the MRO and see if any class has user-defined
            # pure Python __new__ or __init__ method
            for base in obj.__mro__:
                # Now we check if the 'obj' class has an own '__new__' method
                if new is not None and '__new__' in base.__dict__:
                    sig = _get_signature_of(new)
                    if skip_bound_arg:
                        sig = _signature_bound_method(sig)
                    return sig
                # or an own '__init__' method
                elif init is not None and '__init__' in base.__dict__:
                    return _get_signature_of(init)
    
            # At this point we know, that `obj` is a class, with no user-
            # defined '__init__', '__new__', or class-level '__call__'
    
            for base in obj.__mro__[:-1]:
                # Since '__text_signature__' is implemented as a
                # descriptor that extracts text signature from the
                # class docstring, if 'obj' is derived from a builtin
                # class, its own '__text_signature__' may be 'None'.
                # Therefore, we go through the MRO (except the last
                # class in there, which is 'object') to find the first
                # class with non-empty text signature.
                try:
                    text_sig = base.__text_signature__
                except AttributeError:
                    pass
                else:
                    if text_sig:
                        # If 'base' class has a __text_signature__ attribute:
                        # return a signature based on it
                        return _signature_fromstr(sigcls, base, text_sig)
    
            # No '__text_signature__' was found for the 'obj' class.
            # Last option is to check if its '__init__' is
            # object.__init__ or type.__init__.
            if type not in obj.__mro__:
                # We have a class (not metaclass), but no user-defined
                # __init__ or __new__ for it
                if (obj.__init__ is object.__init__ and
                    obj.__new__ is object.__new__):
                    # Return a signature of 'object' builtin.
                    return sigcls.from_callable(object)
                else:
>                   raise ValueError(
                        'no signature found for builtin type {!r}'.format(obj))
E                   ValueError: no signature found for builtin type <class 'git.exc.InvalidGitRepositoryError'>

/usr/lib/python3.12/inspect.py:2635: ValueError
__________________________ test_llm_agent_tool_parse ___________________________

    def test_llm_agent_tool_parse():
>       agent = LLMAgent(api_key="test-key")
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/mnt/c/Users/Vorn/Projects/codexer/tests/test_llm_agent.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/mnt/c/Users/Vorn/Projects/codexer/integration/framework/llm_agent.py:39: in __init__
    self.tools_doc = self._build_tools_doc()
                     ^^^^^^^^^^^^^^^^^^^^^^^
/mnt/c/Users/Vorn/Projects/codexer/integration/framework/llm_agent.py:62: in _build_tools_doc
    sig = str(inspect.signature(fn))
              ^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/inspect.py:3310: in signature
    return Signature.from_callable(obj, follow_wrapped=follow_wrapped,
/usr/lib/python3.12/inspect.py:3054: in from_callable
    return _signature_from_callable(obj, sigcls=cls,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

obj = <class 'git.exc.InvalidGitRepositoryError'>

    def _signature_from_callable(obj, *,
                                 follow_wrapper_chains=True,
                                 skip_bound_arg=True,
                                 globals=None,
                                 locals=None,
                                 eval_str=False,
                                 sigcls):
    
        """Private helper function to get signature for arbitrary
        callable objects.
        """
    
        _get_signature_of = functools.partial(_signature_from_callable,
                                    follow_wrapper_chains=follow_wrapper_chains,
                                    skip_bound_arg=skip_bound_arg,
                                    globals=globals,
                                    locals=locals,
                                    sigcls=sigcls,
                                    eval_str=eval_str)
    
        if not callable(obj):
            raise TypeError('{!r} is not a callable object'.format(obj))
    
        if isinstance(obj, types.MethodType):
            # In this case we skip the first parameter of the underlying
            # function (usually `self` or `cls`).
            sig = _get_signature_of(obj.__func__)
    
            if skip_bound_arg:
                return _signature_bound_method(sig)
            else:
                return sig
    
        # Was this function wrapped by a decorator?
        if follow_wrapper_chains:
            # Unwrap until we find an explicit signature or a MethodType (which will be
            # handled explicitly below).
            obj = unwrap(obj, stop=(lambda f: hasattr(f, "__signature__")
                                    or isinstance(f, types.MethodType)))
            if isinstance(obj, types.MethodType):
                # If the unwrapped object is a *method*, we might want to
                # skip its first parameter (self).
                # See test_signature_wrapped_bound_method for details.
                return _get_signature_of(obj)
    
        try:
            sig = obj.__signature__
        except AttributeError:
            pass
        else:
            if sig is not None:
                # since __text_signature__ is not writable on classes, __signature__
                # may contain text (or be a callable that returns text);
                # if so, convert it
                o_sig = sig
                if not isinstance(sig, (Signature, str)) and callable(sig):
                    sig = sig()
                if isinstance(sig, str):
                    sig = _signature_fromstr(sigcls, obj, sig)
                if not isinstance(sig, Signature):
                    raise TypeError(
                        'unexpected object {!r} in __signature__ '
                        'attribute'.format(o_sig))
                return sig
    
        try:
            partialmethod = obj._partialmethod
        except AttributeError:
            pass
        else:
            if isinstance(partialmethod, functools.partialmethod):
                # Unbound partialmethod (see functools.partialmethod)
                # This means, that we need to calculate the signature
                # as if it's a regular partial object, but taking into
                # account that the first positional argument
                # (usually `self`, or `cls`) will not be passed
                # automatically (as for boundmethods)
    
                wrapped_sig = _get_signature_of(partialmethod.func)
    
                sig = _signature_get_partial(wrapped_sig, partialmethod, (None,))
                first_wrapped_param = tuple(wrapped_sig.parameters.values())[0]
                if first_wrapped_param.kind is Parameter.VAR_POSITIONAL:
                    # First argument of the wrapped callable is `*args`, as in
                    # `partialmethod(lambda *args)`.
                    return sig
                else:
                    sig_params = tuple(sig.parameters.values())
                    assert (not sig_params or
                            first_wrapped_param is not sig_params[0])
                    new_params = (first_wrapped_param,) + sig_params
                    return sig.replace(parameters=new_params)
    
        if isfunction(obj) or _signature_is_functionlike(obj):
            # If it's a pure Python function, or an object that is duck type
            # of a Python function (Cython functions, for instance), then:
            return _signature_from_function(sigcls, obj,
                                            skip_bound_arg=skip_bound_arg,
                                            globals=globals, locals=locals, eval_str=eval_str)
    
        if _signature_is_builtin(obj):
            return _signature_from_builtin(sigcls, obj,
                                           skip_bound_arg=skip_bound_arg)
    
        if isinstance(obj, functools.partial):
            wrapped_sig = _get_signature_of(obj.func)
            return _signature_get_partial(wrapped_sig, obj)
    
        if isinstance(obj, type):
            # obj is a class or a metaclass
    
            # First, let's see if it has an overloaded __call__ defined
            # in its metaclass
            call = _signature_get_user_defined_method(type(obj), '__call__')
            if call is not None:
                return _get_signature_of(call)
    
            new = _signature_get_user_defined_method(obj, '__new__')
            init = _signature_get_user_defined_method(obj, '__init__')
    
            # Go through the MRO and see if any class has user-defined
            # pure Python __new__ or __init__ method
            for base in obj.__mro__:
                # Now we check if the 'obj' class has an own '__new__' method
                if new is not None and '__new__' in base.__dict__:
                    sig = _get_signature_of(new)
                    if skip_bound_arg:
                        sig = _signature_bound_method(sig)
                    return sig
                # or an own '__init__' method
                elif init is not None and '__init__' in base.__dict__:
                    return _get_signature_of(init)
    
            # At this point we know, that `obj` is a class, with no user-
            # defined '__init__', '__new__', or class-level '__call__'
    
            for base in obj.__mro__[:-1]:
                # Since '__text_signature__' is implemented as a
                # descriptor that extracts text signature from the
                # class docstring, if 'obj' is derived from a builtin
                # class, its own '__text_signature__' may be 'None'.
                # Therefore, we go through the MRO (except the last
                # class in there, which is 'object') to find the first
                # class with non-empty text signature.
                try:
                    text_sig = base.__text_signature__
                except AttributeError:
                    pass
                else:
                    if text_sig:
                        # If 'base' class has a __text_signature__ attribute:
                        # return a signature based on it
                        return _signature_fromstr(sigcls, base, text_sig)
    
            # No '__text_signature__' was found for the 'obj' class.
            # Last option is to check if its '__init__' is
            # object.__init__ or type.__init__.
            if type not in obj.__mro__:
                # We have a class (not metaclass), but no user-defined
                # __init__ or __new__ for it
                if (obj.__init__ is object.__init__ and
                    obj.__new__ is object.__new__):
                    # Return a signature of 'object' builtin.
                    return sigcls.from_callable(object)
                else:
>                   raise ValueError(
                        'no signature found for builtin type {!r}'.format(obj))
E                   ValueError: no signature found for builtin type <class 'git.exc.InvalidGitRepositoryError'>

/usr/lib/python3.12/inspect.py:2635: ValueError
=========================== short test summary info ============================
FAILED tests/test_agent.py::test_run_git_status - ImportError: import error i...
FAILED tests/test_agent.py::test_run_git_commit - ImportError: import error i...
FAILED tests/test_git_operations.py::test_git_status_and_commit - gitdb.exc.B...
FAILED tests/test_git_tools.py::test_git_status_and_commit - gitdb.exc.BadNam...
FAILED tests/test_llm_agent.py::test_llm_agent_run_tool - ValueError: no sign...
FAILED tests/test_llm_agent.py::test_llm_agent_final_only - ValueError: no si...
FAILED tests/test_llm_agent.py::test_llm_agent_tool_parse - ValueError: no si...
========================= 7 failed, 26 passed in 6.23s =========================
